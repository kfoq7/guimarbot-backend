<div id="canvas" class="insert-0 absolute"></div>

<style>
  #canvas {
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
  }
</style>

<script>
  import * as THREE from 'three'
  var renderer, scene, camera, composer, portal, skelet, particle
  var textureLoader,
    currentTextureIndex = 0
  var textures = []
  var lastImageChange = 0
  var isChangingTexture = false

  var isDragging = false
  var previousMousePosition = {
    x: 0,
    y: 0
  }
  var rotationVelocity = {
    x: -0.002,
    y: -0.003
  }

  window.onload = function () {
    init()
    animate()
  }

  function init() {
    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true })
    renderer.setPixelRatio(
      window.devicePixelRatio ? window.devicePixelRatio : 1
    )
    renderer.setSize(window.innerWidth, window.innerHeight)
    renderer.shadowMap.enabled = true
    renderer.shadowMap.type = THREE.PCFSoftShadowMap
    renderer.autoClear = false
    renderer.setClearColor(0x000000, 0.0)
    document.getElementById('canvas').appendChild(renderer.domElement)

    scene = new THREE.Scene()
    camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      1,
      1000
    )
    camera.position.z = 500
    scene.add(camera)

    textureLoader = new THREE.TextureLoader()

    // Cargar las texturas
    const imageUrls = [
      '/img/images.jpg',
      '/img/guimarbot.png',
      './images/3.jpg'
    ]
    imageUrls.forEach(url => {
      textures.push(textureLoader.load(url))
    })

    portal = new THREE.Object3D()
    skelet = new THREE.Object3D()
    particle = new THREE.Object3D()

    scene.add(portal)
    scene.add(skelet)
    scene.add(particle)

    // Partículas de fondo
    var geometry = new THREE.TetrahedronGeometry(2, 0)
    var material = new THREE.MeshLambertMaterial({
      color: 0xffffff,
      flatShading: true
    })

    for (var i = 0; i < 1000; i++) {
      var mesh = new THREE.Mesh(geometry, material)
      mesh.position
        .set(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5)
        .normalize()
      mesh.position.multiplyScalar(90 + Math.random() * 700)
      mesh.rotation.set(Math.random() * 2, Math.random() * 2, Math.random() * 2)
      particle.add(mesh)
    }

    // Portal (torus)
    var torusGeometry = new THREE.TorusGeometry(200, 15, 32, 100)
    const torusMaterial = new THREE.MeshPhongMaterial({
      color: 0xffffff,
      emissive: 0x444444,
      specular: 0x555555,
      shininess: 100
    })

    var torusMesh = new THREE.Mesh(torusGeometry, torusMaterial)
    portal.add(torusMesh)

    // Disco central para las imágenes
    var discGeometry = new THREE.CircleGeometry(200, 32)
    var discMaterial = new THREE.MeshBasicMaterial({
      map: textures[0],
      side: THREE.DoubleSide
    })
    var disc = new THREE.Mesh(discGeometry, discMaterial)
    portal.add(disc)

    // Luces
    var ambientLight = new THREE.DirectionalLight(0xffffff, 1)
    ambientLight.position.set(50, 50, 50)
    ambientLight.castShadow = true
    scene.add(ambientLight)

    var lights = []
    lights[0] = new THREE.DirectionalLight(0xffffff, 1)
    lights[0].position.set(1, 0, 0)
    lights[1] = new THREE.DirectionalLight(0x11e8bb, 1)
    lights[1].position.set(0.75, 1, 0.5)
    lights[2] = new THREE.DirectionalLight(0x8200c9, 1)
    lights[2].position.set(-0.75, -1, 0.5)
    scene.add(lights[0])
    scene.add(lights[1])
    scene.add(lights[2])

    window.addEventListener('resize', onWindowResize, false)
  }

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight
    camera.updateProjectionMatrix()
    renderer.setSize(window.innerWidth, window.innerHeight)
  }

  function checkPortalRotation() {
    // Obtener el vector normal del disco (asumiendo que está en el eje Z local del portal)
    const normalVector = new THREE.Vector3(0, 0, 1)
    normalVector.applyQuaternion(portal.quaternion)

    // Calcular el producto punto con la dirección de la cámara
    const dotProduct = normalVector.dot(
      camera.getWorldDirection(new THREE.Vector3())
    )

    // Si el disco está "de espaldas" y no estamos en medio de un cambio
    if (dotProduct < -0.95 && !isChangingTexture) {
      isChangingTexture = true
      currentTextureIndex = (currentTextureIndex + 1) % textures.length
      // Actualizar la textura del disco
      portal.children[1].material.map = textures[currentTextureIndex]
      portal.children[1].material.needsUpdate = true
    }

    // Resetear el flag cuando el disco vuelve a estar de frente
    else if (dotProduct > 0.95) {
      isChangingTexture = false
    }
  }

  function animate(timestamp) {
    requestAnimationFrame(animate)

    particle.rotation.y -= 0.004
    portal.rotation.x -= 0.002
    portal.rotation.y -= 0.003
    skelet.rotation.x -= 0.001
    skelet.rotation.y += 0.002

    checkPortalRotation()

    renderer.clear()
    renderer.render(scene, camera)
  }
</script>
